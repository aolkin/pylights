<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Working with Console Files &mdash; EOL AutoKey v0.5</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/eol311.ico"/>
    <link rel="top" title="EOL AutoKey v0.5" href="index.html" />
    <link rel="prev" title="&lt;no title&gt;" href="entities.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="entities.html" title="&lt;no title&gt;"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">EOL AutoKey v0.5</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="working-with-console-files">
<h1>Working with Console Files<a class="headerlink" href="#working-with-console-files" title="Permalink to this headline">¶</a></h1>
<p>This software has limited support for reading and writing certain files used or created by
ETC consoles and software. Fixture Personalities may be completely read and written, and parts
of showfiles may be read (eventually...that&#8217;s not implemented yet).</p>
<div class="section" id="working-with-etc-showfiles">
<h2>Working with ETC Showfiles<a class="headerlink" href="#working-with-etc-showfiles" title="Permalink to this headline">¶</a></h2>
<p><strong>#TODO</strong></p>
</div>
<div class="section" id="module-etcfiles.personality">
<span id="working-with-etc-fixture-personalities"></span><h2>Working with ETC Fixture Personalities<a class="headerlink" href="#module-etcfiles.personality" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#module-etcfiles.personality" title="etcfiles.personality: Allows you to use ETC's Fixture Personality files."><tt class="xref py py-mod docutils literal"><span class="pre">personality</span></tt></a> module provides two public classes for working with Fixture
Personalities. Unlike <tt class="xref py py-class docutils literal"><span class="pre">Showfile</span></tt>s, the <a class="reference internal" href="#etcfiles.personality.Personality" title="etcfiles.personality.Personality"><tt class="xref py py-class docutils literal"><span class="pre">Personality</span></tt></a> class may
be read from and written to ETC personality files directly and should have no problems.</p>
<dl class="class">
<dt id="etcfiles.personality.Personality">
<em class="property">class </em><tt class="descclassname">etcfiles.personality.</tt><tt class="descname">Personality</tt><big>(</big><em>label=''</em>, <em>channels=</em><span class="optional">[</span><span class="optional">]</span>, <em>remdim=False</em><big>)</big><a class="headerlink" href="#etcfiles.personality.Personality" title="Permalink to this definition">¶</a></dt>
<dd><p>No arguments need to be supplied when a <a class="reference internal" href="#etcfiles.personality.Personality" title="etcfiles.personality.Personality"><tt class="xref py py-class docutils literal"><span class="pre">Personality</span></tt></a> is created, although they may be.
If <a class="reference internal" href="#etcfiles.personality.Personality.channels" title="etcfiles.personality.Personality.channels"><tt class="xref py py-obj docutils literal"><span class="pre">channels</span></tt></a> is supplied, it must be a sequence of <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>s.</p>
<p>Alternatively, a personality may be loaded from a file by way of <a class="reference internal" href="#etcfiles.personality.Personality.from_file" title="etcfiles.personality.Personality.from_file"><tt class="xref py py-meth docutils literal"><span class="pre">from_file()</span></tt></a>.</p>
<dl class="classmethod">
<dt id="etcfiles.personality.Personality.from_file">
<em class="property">classmethod </em><tt class="descname">from_file</tt><big>(</big><em>fn</em>, <em>writeable=True</em><big>)</big><a class="headerlink" href="#etcfiles.personality.Personality.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Use this method to load a <a class="reference internal" href="#etcfiles.personality.Personality" title="etcfiles.personality.Personality"><tt class="xref py py-class docutils literal"><span class="pre">Personality</span></tt></a> from an ETC personality file. <tt class="xref py py-obj docutils literal"><span class="pre">fn</span></tt> is the
filename to load from, and <tt class="xref py py-obj docutils literal"><span class="pre">writeable</span></tt> controls whether the filename will be remembered.</p>
<p>For a little more explanation, see <a class="reference internal" href="#etcfiles.Readable.from_file" title="etcfiles.Readable.from_file"><tt class="xref py py-meth docutils literal"><span class="pre">etcfiles.Readable.from_file()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="etcfiles.personality.Personality.write">
<tt class="descname">write</tt><big>(</big><em>fn=None</em><big>)</big><a class="headerlink" href="#etcfiles.personality.Personality.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the personality in the ETC format to the specified file. If <tt class="xref py py-obj docutils literal"><span class="pre">fn</span></tt> is <a class="reference external" href="http://docs.python.org/library/constants.html#None" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">None</span></tt></a> and the
filename used with <a class="reference internal" href="#etcfiles.personality.Personality.from_file" title="etcfiles.personality.Personality.from_file"><tt class="xref py py-meth docutils literal"><span class="pre">from_file()</span></tt></a> was remembered, it will use that filename.</p>
</dd></dl>

<p>These attributes are the fields in an ETC personality:</p>
<dl class="attribute">
<dt id="etcfiles.personality.Personality.label">
<tt class="descname">label</tt><a class="headerlink" href="#etcfiles.personality.Personality.label" title="Permalink to this definition">¶</a></dt>
<dd><p>This must be a string no longer than twelve characters. Attempting to set this to a longer
string will result in a <tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.Personality.remote_dimmer">
<tt class="descname">remote_dimmer</tt><a class="headerlink" href="#etcfiles.personality.Personality.remote_dimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>This must be a boolean value, and will result in a <tt class="xref py py-exc docutils literal"><span class="pre">ValueError</span></tt> if you attempt to set
it otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.Personality.channels">
<tt class="descname">channels</tt><a class="headerlink" href="#etcfiles.personality.Personality.channels" title="Permalink to this definition">¶</a></dt>
<dd><p>A special sequence object acting partially as a list of <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> objects
representing each channel/dimmer defined by the personality. If it is assigned to, it must
be assigned a sequence of <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>s.</p>
<dl class="docutils">
<dt>You may retrieve individual <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> objects from the list using index notation::</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Returns the first channel of p</span>
</pre></div>
</div>
</dd>
</dl>
<p>However, you may not assign new <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>s. Instead, use <a class="reference internal" href="#etcfiles.personality.Personality.channels.add" title="etcfiles.personality.Personality.channels.add"><tt class="xref py py-meth docutils literal"><span class="pre">channels.add()</span></tt></a> to
replace channels (see its documentation).</p>
</dd></dl>

<p>Channels may be added to a personality through its <a class="reference internal" href="#etcfiles.personality.Personality.addChannel" title="etcfiles.personality.Personality.addChannel"><tt class="xref py py-meth docutils literal"><span class="pre">addChannel()</span></tt></a> method, or its
<a class="reference internal" href="#etcfiles.personality.Personality.channels.add" title="etcfiles.personality.Personality.channels.add"><tt class="xref py py-meth docutils literal"><span class="pre">channels.add()</span></tt></a> method. To replace existing channels, simply create a new one with the
same <a class="reference internal" href="#etcfiles.personality.PChannel.dimmer" title="etcfiles.personality.PChannel.dimmer"><tt class="xref py py-attr docutils literal"><span class="pre">PChannel.dimmer</span></tt></a> value as an existing one and add it using either of these methods,
and it will replace the existing one.</p>
<dl class="method">
<dt id="etcfiles.personality.Personality.addChannel">
<tt class="descname">addChannel</tt><big>(</big><em>atype</em>, <em>dimmer=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#etcfiles.personality.Personality.addChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will create a new <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> for you with whatever options you specify
and add it to <a class="reference internal" href="#etcfiles.personality.Personality.channels" title="etcfiles.personality.Personality.channels"><tt class="xref py py-attr docutils literal"><span class="pre">channels</span></tt></a>. If you specify a <tt class="xref py py-obj docutils literal"><span class="pre">dimmer</span></tt>, it will create the new
<a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> at that position, overwriting any that may have previously been there.
If you do not specify a dimmer, it will just add this channel at the end, after the
currently last channel.</p>
<p>It will accept either a string or an integer for <tt class="xref py py-obj docutils literal"><span class="pre">atype</span></tt>. If it does not get an integer,
it will perform a lookup of the string in <a class="reference internal" href="#etcfiles.personality._attribute_types" title="etcfiles.personality._attribute_types"><tt class="xref py py-data docutils literal"><span class="pre">_attribute_types</span></tt></a> to determine its
integer value.</p>
<p>Any additional arguments passed to <a class="reference internal" href="#etcfiles.personality.Personality.addChannel" title="etcfiles.personality.Personality.addChannel"><tt class="xref py py-meth docutils literal"><span class="pre">addChannel()</span></tt></a> are just passed on to the
<a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> constructor.</p>
</dd></dl>

<dl class="method">
<dt id="etcfiles.personality.Personality.channels.add">
<tt class="descclassname">channels.</tt><tt class="descname">add</tt><big>(</big><em>channel</em><big>)</big><a class="headerlink" href="#etcfiles.personality.Personality.channels.add" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes an already-instantiated <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> object and adds it to
<a class="reference internal" href="#etcfiles.personality.Personality.channels" title="etcfiles.personality.Personality.channels"><tt class="xref py py-attr docutils literal"><span class="pre">channels</span></tt></a> at whatever position is specified by <a class="reference internal" href="#etcfiles.personality.PChannel.dimmer" title="etcfiles.personality.PChannel.dimmer"><tt class="xref py py-attr docutils literal"><span class="pre">PChannel.dimmer</span></tt></a> for that
channel, overwriting any that may already have been there. Any attempts to add
non-<a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> objects will raise a <tt class="xref py py-exc docutils literal"><span class="pre">TypeError</span></tt>.</p>
<p>If a <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> is added with a dimmer beyond the length of the <a class="reference internal" href="#etcfiles.personality.Personality.channels" title="etcfiles.personality.Personality.channels"><tt class="xref py py-attr docutils literal"><span class="pre">channels</span></tt></a>
list, blank <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> objects are created to fill in the space between the current
last channel and the dimmer position of the new one. The <a class="reference internal" href="#etcfiles.personality.PChannel.atype" title="etcfiles.personality.PChannel.atype"><tt class="xref py py-attr docutils literal"><span class="pre">atype</span></tt></a> of these
objects is 0, or &#8220;Not Used&#8221;.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="etcfiles.personality.PChannel">
<em class="property">class </em><tt class="descclassname">etcfiles.personality.</tt><tt class="descname">PChannel</tt><big>(</big><em>dimmer</em>, <em>atype=0</em>, <em>home=0</em>, <em>dispformat=0</em>, <em>attrs=None</em>, <em>type=None</em>, <em>independent=False</em>, <em>LTP=False</em>, <em>sixteenbit=False</em>, <em>flipped=False</em><big>)</big><a class="headerlink" href="#etcfiles.personality.PChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>When constructing a new <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>, the only required argument is the channel
(<a class="reference internal" href="#etcfiles.personality.PChannel.dimmer" title="etcfiles.personality.PChannel.dimmer"><tt class="xref py py-obj docutils literal"><span class="pre">dimmer</span></tt></a>) where this <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> will be placed. This must be specified when the object
is created, as it cannot be changed after instantiation.</p>
<dl class="attribute">
<dt id="etcfiles.personality.PChannel.dimmer">
<tt class="descname">dimmer</tt><a class="headerlink" href="#etcfiles.personality.PChannel.dimmer" title="Permalink to this definition">¶</a></dt>
<dd><p>This attribute provides read-only access to the channel this <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> resides at.</p>
</dd></dl>

<p>The type of a channel and other attributes do not need to be specified when the
<a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> is created and they can be changed later. Additionally, most provide
multiple ways of accessing/setting their values.</p>
<p>While the channel type does not need to be specified at <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> creation time, it is
reccomended. This can be done by either specifying the <a class="reference internal" href="#etcfiles.personality.PChannel.atype" title="etcfiles.personality.PChannel.atype"><tt class="xref py py-attr docutils literal"><span class="pre">atype</span></tt></a> parameter or the
<a class="reference internal" href="#etcfiles.personality.PChannel.type" title="etcfiles.personality.PChannel.type"><tt class="xref py py-attr docutils literal"><span class="pre">type</span></tt></a> parameter. After creation, the type can be changed via those attributes in the
same way:</p>
<dl class="attribute">
<dt id="etcfiles.personality.PChannel.type">
<tt class="descname">type</tt><a class="headerlink" href="#etcfiles.personality.PChannel.type" title="Permalink to this definition">¶</a></dt>
<dd><p>This must be a string from <a class="reference internal" href="#etcfiles.personality._attribute_types" title="etcfiles.personality._attribute_types"><tt class="xref py py-data docutils literal"><span class="pre">_attribute_types</span></tt></a>. It provides a more readable way of
accessing the type of a <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.PChannel.atype">
<tt class="descname">atype</tt><a class="headerlink" href="#etcfiles.personality.PChannel.atype" title="Permalink to this definition">¶</a></dt>
<dd><p>This should be an integer in the range 0-64.</p>
</dd></dl>

<p>These fields have only this one way of setting them:</p>
<dl class="attribute">
<dt id="etcfiles.personality.PChannel.home">
<tt class="descname">home</tt><a class="headerlink" href="#etcfiles.personality.PChannel.home" title="Permalink to this definition">¶</a></dt>
<dd><p>This should be an integer in the range 0-255.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.PChannel.dispformat">
<tt class="descname">dispformat</tt><a class="headerlink" href="#etcfiles.personality.PChannel.dispformat" title="Permalink to this definition">¶</a></dt>
<dd><p>This should be an integer that maps to one of the values in <a class="reference internal" href="#etcfiles.personality._display_types" title="etcfiles.personality._display_types"><tt class="xref py py-data docutils literal"><span class="pre">_display_types</span></tt></a>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ETC console I work with does not use these fields, but they exist in ETC&#8217;s
Personality Editor, so they are supported here.</p>
</div>
<p>The channel attributes are stored as one byte in ETC&#8217;s format, so they provide a way to
access that representation. They can also be accessed as invididual attributes.</p>
<dl class="attribute">
<dt id="etcfiles.personality.PChannel.attrs">
<tt class="descname">attrs</tt><a class="headerlink" href="#etcfiles.personality.PChannel.attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>An integer representation of the channel attributes byte. If this is provided at creation
time, it overrides any attributes that may have been set individually.</p>
</dd></dl>

<dl class="method">
<dt id="etcfiles.personality.PChannel.niceattrs">
<tt class="descname">niceattrs</tt><big>(</big><big>)</big><a class="headerlink" href="#etcfiles.personality.PChannel.niceattrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a nice human-readable string representation of the <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a>&#8216;s channel
attributes, mainly for use in display.</p>
</dd></dl>

<p>Channel attributes can also be accessed and set individually, in which case they should only
be set to boolean values. If unspecified, they default to <a class="reference external" href="http://docs.python.org/library/constants.html#False" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">False</span></tt></a>.</p>
<dl class="attribute">
<dt id="etcfiles.personality.PChannel.independent">
<tt class="descname">independent</tt><a class="headerlink" href="#etcfiles.personality.PChannel.independent" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the channel is affected by the <em class="xref std std-term">Grandmaster</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.PChannel.LTP">
<tt class="descname">LTP</tt><a class="headerlink" href="#etcfiles.personality.PChannel.LTP" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, the channel will not reset to zero (or its <a class="reference internal" href="#etcfiles.personality.PChannel.home" title="etcfiles.personality.PChannel.home"><tt class="xref py py-attr docutils literal"><span class="pre">home</span></tt></a>?) automatically.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.PChannel.flipped">
<tt class="descname">flipped</tt><a class="headerlink" href="#etcfiles.personality.PChannel.flipped" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, the channel output will be the opposite of the value you set.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.personality.PChannel.sixteenbit">
<tt class="descname">sixteenbit</tt><a class="headerlink" href="#etcfiles.personality.PChannel.sixteenbit" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses two channels to represent a larger value, giving finer-grained control.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">I don&#8217;t fully understand how this is represented, so while it should read fine,
attempts to set it may cause unexpected results.</p>
</div>
<p>Neither <a class="reference internal" href="#etcfiles.personality.Personality" title="etcfiles.personality.Personality"><tt class="xref py py-class docutils literal"><span class="pre">Personality</span></tt></a> nor <a class="reference internal" href="#etcfiles.personality.PChannel" title="etcfiles.personality.PChannel"><tt class="xref py py-class docutils literal"><span class="pre">PChannel</span></tt></a> will automatically manage 16 Bit channels
for you, so if you wish to add one you must do so yourself. A 16 Bit channel is internally
represented (by ETC) as two channels. It is unknown how much the settings of the second
channel matter, but if you wish to use a 16 Bit channel, you must create it manually. It is
reccomended to use the same settings as the first channel, except without the 16 Bit
attribute set, and with the dimmer set one up, of course.</p>
</dd></dl>

</dd></dl>

<p>The <a class="reference internal" href="#module-etcfiles.personality" title="etcfiles.personality: Allows you to use ETC's Fixture Personality files."><tt class="xref py py-mod docutils literal"><span class="pre">personality</span></tt></a> module provides two module level constants to assist in
generating nicer representations of the data stored in a personality. They are mainly used
internally, but are documented here anyway. They are each lists, since they only need to map
a contiguous set of integers starting at 0, for which list indices work fine.</p>
<dl class="data">
<dt id="etcfiles.personality._attribute_types">
<tt class="descclassname">etcfiles.personality.</tt><tt class="descname">_attribute_types</tt><a class="headerlink" href="#etcfiles.personality._attribute_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This is ETC&#8217;s list of personality channel types, and is used internally to map type names
to integers and vice-versa.</p>
</dd></dl>

<dl class="data">
<dt id="etcfiles.personality._display_types">
<tt class="descclassname">etcfiles.personality.</tt><tt class="descname">_display_types</tt><a class="headerlink" href="#etcfiles.personality._display_types" title="Permalink to this definition">¶</a></dt>
<dd><p>This maps the integers used to represent different channel &#8220;display types&#8221; to strings.
There are only four of them.</p>
</dd></dl>

</div>
<div class="section" id="module-etcfiles">
<span id="adding-binary-file-io-support-to-custom-classes"></span><h2>Adding Binary File IO Support to Custom Classes<a class="headerlink" href="#module-etcfiles" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These classes are used by the modules of the etcfiles package and probably have no
external use, so they are just documented here because they can be!</p>
</div>
<p>The base <a class="reference internal" href="#module-etcfiles" title="etcfiles: Provides functionality for representing and working with objects stored in binary files created by ETC software."><tt class="xref py py-mod docutils literal"><span class="pre">etcfiles</span></tt></a> module contains base classes that implement some binary
file IO. These can be inherited to use their functionality in custom classes. To make a class
readable, inherit <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a>. To make a class writeable, inherit <a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a>.
You may use any combination of the two classes, so a class can be readable and writeable,
or even just writeable.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><em>Only for Python 2.x</em>: Any class that inherits from <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a> or
<a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a> is automatically a new-style class, as they both inherit from <a class="reference external" href="http://docs.python.org/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">object</span></tt></a>.</p>
</div>
<dl class="class">
<dt id="etcfiles.Readable">
<em class="property">class </em><tt class="descclassname">etcfiles.</tt><tt class="descname">Readable</tt><a class="headerlink" href="#etcfiles.Readable" title="Permalink to this definition">¶</a></dt>
<dd><p>To make a class readable, inherit from the <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a> class. This will provide
your class with two classmethods, <a class="reference internal" href="#etcfiles.Readable.from_string" title="etcfiles.Readable.from_string"><tt class="xref py py-meth docutils literal"><span class="pre">from_string()</span></tt></a> and <a class="reference internal" href="#etcfiles.Readable.from_file" title="etcfiles.Readable.from_file"><tt class="xref py py-meth docutils literal"><span class="pre">from_file()</span></tt></a>.</p>
<p>However, in order to actually make a class readable or writeable, it must define (at least)
<a class="reference internal" href="#etcfiles.Readable._struct_format" title="etcfiles.Readable._struct_format"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_format</span></tt></a> and <a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a> at the class level.</p>
<dl class="attribute">
<dt id="etcfiles.Readable._struct_format">
<tt class="descname">_struct_format</tt><a class="headerlink" href="#etcfiles.Readable._struct_format" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/library/struct.html#struct" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a> format string, it will be passed to <a class="reference external" href="http://docs.python.org/library/struct.html#struct.unpack" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">struct.unpack()</span></tt></a> when parsing
the file.</p>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.Readable._struct_fields">
<tt class="descname">_struct_fields</tt><a class="headerlink" href="#etcfiles.Readable._struct_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>A sequence defining how the objects returned from unpacking the binary data will be passed
to the constructor. It should contain the name of the argument each field should be passed
to the constructor as as strings, and <a class="reference external" href="http://docs.python.org/library/constants.html#None" title="(in Python v2.7)"><tt class="xref py py-obj docutils literal"><span class="pre">None</span></tt></a> for fields that should be ignored.</p>
<p>If a field name appears multiple times, the field will passed to your constructor as a
list containing all fields with that name.</p>
<p id="recursive-struct-packing"><strong>Recursive Field Parsing:</strong></p>
<p>Additionally, for fields which should further be parsed into custom objects, place a <tt class="xref py py-obj docutils literal"><span class="pre">*</span></tt>
in front of the field name, and define <a class="reference internal" href="#etcfiles.Readable._struct_structs" title="etcfiles.Readable._struct_structs"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_structs</span></tt></a>. Any field in
<a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a> which is preceded by a <tt class="xref py py-obj docutils literal"><span class="pre">*</span></tt> will be looked up in
<a class="reference internal" href="#etcfiles.Readable._struct_structs" title="etcfiles.Readable._struct_structs"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_structs</span></tt></a>, and the <a class="reference internal" href="#etcfiles.Readable.from_string" title="etcfiles.Readable.from_string"><tt class="xref py py-meth docutils literal"><span class="pre">from_string()</span></tt></a> constructor of the specified class
will be called on the field&#8217;s value before it is used to construct a new object.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is used by <a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a> objects as well to properly format null
fields and recursively pack objects.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="etcfiles.Readable._struct_structs">
<tt class="descname">_struct_structs</tt><a class="headerlink" href="#etcfiles.Readable._struct_structs" title="Permalink to this definition">¶</a></dt>
<dd><p>A dictionary mapping field names (without the <tt class="xref py py-obj docutils literal"><span class="pre">*</span></tt>) to custom classes (which must in turn
be <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a>).</p>
</dd></dl>

<p>Inheriting the <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a> class provides your class with two classmethods that can be
used to create an instance from binary data.</p>
<dl class="classmethod">
<dt id="etcfiles.Readable.from_string">
<em class="property">classmethod </em><tt class="descname">from_string</tt><big>(</big><em>string</em><big>)</big><a class="headerlink" href="#etcfiles.Readable.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a bytestring and returns an object loaded from that bytestring.</p>
<p>It will first attempt to construct a new object using its default constructor,
passing in the fields using dictionary expansion. If that fails because the method
signature does not match, it will attempt to use the <a class="reference internal" href="#etcfiles.Readable.from_struct" title="etcfiles.Readable.from_struct"><tt class="xref py py-meth docutils literal"><span class="pre">from_struct()</span></tt></a> classmethod of
the class, passing in the same arguments. This allows you to have a constructor with a
signature that is incompatible with the binary format.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is also used internally when recursively parsing objects.</p>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="etcfiles.Readable.from_file">
<em class="property">classmethod </em><tt class="descname">from_file</tt><big>(</big><em>fn</em>, <em>writeable=True</em><big>)</big><a class="headerlink" href="#etcfiles.Readable.from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper around <a class="reference internal" href="#etcfiles.Readable.from_string" title="etcfiles.Readable.from_string"><tt class="xref py py-meth docutils literal"><span class="pre">from_string()</span></tt></a>, this takes a filename and an optional boolean
flag. It reads from the specified file and then calls <a class="reference internal" href="#etcfiles.Readable.from_string" title="etcfiles.Readable.from_string"><tt class="xref py py-meth docutils literal"><span class="pre">from_string()</span></tt></a> on its
contents, and returns the result.</p>
<p>Additionally, if the optional boolean <tt class="xref py py-obj docutils literal"><span class="pre">writeable</span></tt> is True and the class inherits from
Writeable, the specified filename will be remembered for when the object is written
to a file.</p>
</dd></dl>

<dl class="classmethod">
<dt id="etcfiles.Readable.from_struct">
<em class="property">classmethod </em><tt class="descname">from_struct</tt><big>(</big><em>**args</em><big>)</big><a class="headerlink" href="#etcfiles.Readable.from_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>If your constructor has a signature that is incompatible with the binary format/fields
as defined in <a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a>, you must write a <a class="reference internal" href="#etcfiles.Readable.from_struct" title="etcfiles.Readable.from_struct"><tt class="xref py py-meth docutils literal"><span class="pre">from_struct()</span></tt></a> classmethod.
<a class="reference internal" href="#etcfiles.Readable.from_struct" title="etcfiles.Readable.from_struct"><tt class="xref py py-meth docutils literal"><span class="pre">from_struct()</span></tt></a> will still be called the same way as your constructor, using a
dictionary expansion of the fields specified in <a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a> and their values.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is NOT defined by <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a>!</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="etcfiles.Writeable">
<em class="property">class </em><tt class="descclassname">etcfiles.</tt><tt class="descname">Writeable</tt><a class="headerlink" href="#etcfiles.Writeable" title="Permalink to this definition">¶</a></dt>
<dd><p>This class functions very much like <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a>, with a few notable differences:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a> is not required to write an object. It is still useful,
however, to easily write null fields, and if you want
<a class="reference internal" href="#recursive-struct-packing"><em>recursive object packing</em></a> you must define it.</li>
<li><a class="reference internal" href="#etcfiles.Readable._struct_structs" title="etcfiles.Readable._struct_structs"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_structs</span></tt></a> is unnecessary even if you are using
<a class="reference internal" href="#recursive-struct-packing"><em>recursive object packing</em></a>, because <a class="reference internal" href="#etcfiles.Writeable.to_string" title="etcfiles.Writeable.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a>
just calls object&#8217;s <a class="reference internal" href="#etcfiles.Writeable.to_string" title="etcfiles.Writeable.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a> methods. This means that subobjects must still be
<a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a>.</li>
<li><a class="reference internal" href="#etcfiles.Readable.from_struct" title="etcfiles.Readable.from_struct"><tt class="xref py py-meth docutils literal"><span class="pre">from_struct()</span></tt></a> is, of course, never necessary, but a new method,
<a class="reference internal" href="#etcfiles.Writeable.to_struct" title="etcfiles.Writeable.to_struct"><tt class="xref py py-meth docutils literal"><span class="pre">to_struct()</span></tt></a>, must be defined.</li>
</ol>
<p>Like <a class="reference internal" href="#etcfiles.Readable" title="etcfiles.Readable"><tt class="xref py py-class docutils literal"><span class="pre">Readable</span></tt></a>, <a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a> defines two methods for binary IO, <a class="reference internal" href="#etcfiles.Writeable.to_string" title="etcfiles.Writeable.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a>
and <a class="reference internal" href="#etcfiles.Writeable.write" title="etcfiles.Writeable.write"><tt class="xref py py-meth docutils literal"><span class="pre">write()</span></tt></a>.</p>
<dl class="method">
<dt id="etcfiles.Writeable.to_string">
<tt class="descname">to_string</tt><big>(</big><big>)</big><a class="headerlink" href="#etcfiles.Writeable.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference external" href="http://docs.python.org/library/struct.html#struct" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a> packed bytestring of the object.</p>
<p>This method will call the object&#8217;s <a class="reference internal" href="#etcfiles.Writeable.to_struct" title="etcfiles.Writeable.to_struct"><tt class="xref py py-meth docutils literal"><span class="pre">to_struct()</span></tt></a> method to get a list of field data.
It expects a sequence of data suitable for packing into a <a class="reference external" href="http://docs.python.org/library/struct.html#struct" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">struct</span></tt></a>, although if
specified in <a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a> certain fields will be
<a class="reference internal" href="#recursive-struct-packing"><em>recursively packed</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="etcfiles.Writeable.write">
<tt class="descname">write</tt><big>(</big><em>fn=None</em><big>)</big><a class="headerlink" href="#etcfiles.Writeable.write" title="Permalink to this definition">¶</a></dt>
<dd><p>A wrapper around <a class="reference internal" href="#etcfiles.Writeable.to_string" title="etcfiles.Writeable.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a>, this writes the data returned by <a class="reference internal" href="#etcfiles.Writeable.to_string" title="etcfiles.Writeable.to_string"><tt class="xref py py-meth docutils literal"><span class="pre">to_string()</span></tt></a>
to the specified file, or, if none is specified and a filename was remembered when
loading the object from a file, that remembered filename will be used.</p>
<p>Returns True on success, for no particular reason.</p>
</dd></dl>

<p>In order to make a class properly writeable, you must define a <a class="reference internal" href="#etcfiles.Writeable.to_struct" title="etcfiles.Writeable.to_struct"><tt class="xref py py-meth docutils literal"><span class="pre">to_struct()</span></tt></a> method:</p>
<dl class="method">
<dt id="etcfiles.Writeable.to_struct">
<tt class="descname">to_struct</tt><big>(</big><big>)</big><a class="headerlink" href="#etcfiles.Writeable.to_struct" title="Permalink to this definition">¶</a></dt>
<dd><p>You must provide this method to make a class writeable. It is given no arguments and should
return a sequence of fields to be packed. Any non integer/string fields (depending on your
format string) must correspond with <tt class="xref py py-obj docutils literal"><span class="pre">*</span></tt>-marked fields in <a class="reference internal" href="#etcfiles.Readable._struct_fields" title="etcfiles.Readable._struct_fields"><tt class="xref py py-attr docutils literal"><span class="pre">_struct_fields</span></tt></a>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This method is NOT defined by <a class="reference internal" href="#etcfiles.Writeable" title="etcfiles.Writeable"><tt class="xref py py-class docutils literal"><span class="pre">Writeable</span></tt></a>!</p>
</div>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Working with Console Files</a><ul>
<li><a class="reference internal" href="#working-with-etc-showfiles">Working with ETC Showfiles</a></li>
<li><a class="reference internal" href="#module-etcfiles.personality">Working with ETC Fixture Personalities</a></li>
<li><a class="reference internal" href="#module-etcfiles">Adding Binary File IO Support to Custom Classes</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="entities.html"
                        title="previous chapter">&lt;no title&gt;</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/etcfiles.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="entities.html" title="&lt;no title&gt;"
             >previous</a> |</li>
        <li><a href="index.html">EOL AutoKey v0.5</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013 Aaron Olkin.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>